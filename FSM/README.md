#有限状态机FSM详解及其实现
----
有限状态机,也称为FSM(Finite State Machine)，其在任意时刻都处于有限状态集合中的某一状态。当其获得一个输入字符时，将从当前状态转换到另一个状态，或者仍然保持在当前状态。任何一个FSM都可以用状态转换图来描述，图中的节点表示FSM中的一个状态，有向加权边表示输入字符时状态的变化。如果图中不存在与当前状态与输入字符对应的有向边，则FSM将进入“消亡状态(Doom State)”，此后FSM将一直保持“消亡状态”。状态转换图中还有两个特殊状态：状态1称为“起始状态”，表示FSM的初始状态。状态6称为“结束状态”，表示成功识别了所输入的字符序列。

在启动一个FSM时，首先必须将FSM置于“起始状态”，然后输入一系列字符，最终，FSM会到达“结束状态”或者“消亡状态”

[原文出处](https://www.cnblogs.com/benxintuzi/p/4931258.html)
![]("FSM.png")
**说明：**
在通常的FSM模型中，一般还存在一个“接受状态”，并且FSM可以从“接受状态”转换到另一个状态，只有在识别最后一个字符后，才会根据最终状态来决定是否接受所输入的字符串。此外，也可以将“其实状态”也作为接受状态，因此空的输入序列也是可以接受的。

## FSM的实现
程序设计思路大致如下：

- 使用状态转换图描述FSM
- 状态转换图中的结点对应不同的状态对象
- 每个状态对象通过一个输入字符转换到另一个状态上，或者保持原状态不变。

通过输入字符从一个状态切换到另一个状态的过程，我们称之为一个映射。在计算机程序设计中，我们可以有两种表示映射的方法：

- 通过算法表示，即“可执行代码（Executable Code）”方式
- 通过一张映射表，即“被动数据（Passive Data）”方式

###如下详细介绍这两种实现方式：
- 通过Executable Code实现映射的FSM:

这种方式主要是通过条件分支来处理不同的字符，如if或者switch语句块。
代码：
fsm_with_executable_code.h
fsm_with_executable_code.cc
test_with_executable_code.cc

- 通过Passive Data实现映射的FSM:

在如上的switch分支中，其使用类型大致相同，因此，我们可以考虑将相似的信息保存到一张表中，这样就可以在程序中避免很多函数调用。在每个状态中都使用一张转换表来表示映射关系，转换表的索引使用输入字符来表示。此外，由于通过转换表就可以描述不同状态之间的变化，那么就没有必要将每种状态定义为一个类了，即不需要多余的继承和虚函数了，仅使用一个State即可。
代码：
fsm_with_passive_data.h
fsm_with_passive_data.cc
test_with_passive_data.cc

###通用FSM的设计
如果类Fsm可以表示任意类型的FSM,那么就更符合程序设计的要求了。在构造函数中执行的具体配置应该被泛化为一种机制，我们通过这种机制来建立任意的FSM。在Fsm的构造函数中，应该将转换表作为一个参数传入，而非包含具体的转换表，如此，则不需要将转换表的大小硬编码到Fsm中了。因此，在构造函数中必须动态地创建这个存放转换表的内存空间，在析构函数中记着销毁这块内存。
代码：
fsm_with_generalization.h
fsm_with_generalization.cc
test_with_generalization.cc
当然也可以将上述程序中的转换表不放在主程序中，而是由一个派生自Fsm的子类SpecificFsm提供，在SpecificFsm中设置具体的转换表，然后通过SpecificFsm的初始化列表传到基类Fsm中，这样在主程序中就可以使用SpecificFsm来进行操作了。